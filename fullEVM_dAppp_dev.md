# Full EVM dApp: Build and deploy

Building and deploying a full EVM (Ethereum Virtual Machine) application (DApp) from the Command Line Interface (CLI) is a multi-step process.

We will use the popular Hardhat framework for the contract side and a standard React setup for the frontend, demonstrating a typical integrated project structure.


1. âš™ï¸ Initial Setup and Project Structure


1.1 Global Prerequisites


Make sure you have Node.js (with npm) and Git installed.


| CLI Command | Description |
|---|---|
| node -v | Check Node.js version |
| npm -v | Check npm version |


1.2 Create the Monorepo Structure


We will create a parent directory to hold both the backend (contracts) and the frontend.


| Path | Description |
|---|---|
| my-evm-dapp/ | Root Project Directory |
| my-evm-dapp/backend/ | Hardhat project for contracts/deployment |
| my-evm-dapp/frontend/ | React/Next.js project for the UI |


# 1. Create the root directory

```
mkdir my-evm-dapp

cd my-evm-dapp

```

# 2. Setup the backend (Hardhat)

```
mkdir backend

cd backend

npm init -y

npm install --save-dev hardhat

npx hardhat init # Select "Create a basic sample project"

cd .. # Go back to my-evm-dapp

```

# 3. Setup the frontend (React example)

```
npx create-react-app frontend

cd frontend

npm install ethers # Library to interact with the blockchain

cd .. # Go back to my-evm-dapp
```

2. ðŸ“ Backend (Smart Contract) CLI Steps
   
We focus on the my-evm-dapp/backend/ directory, which now contains the default Hardhat structure:

```
my-evm-dapp/backend/
â”œâ”€â”€ contracts/        # Your Solidity files live here
â”‚   â””â”€â”€ Lock.sol      # (Example contract from Hardhat init)
â”œâ”€â”€ scripts/          # Deployment scripts (Node.js)
â”‚   â””â”€â”€ deploy.js
â”œâ”€â”€ test/             # Test files (JavaScript/TypeScript)
â”œâ”€â”€ hardhat.config.js # Configuration file
â””â”€â”€ package.json

```

2.1 Write and Compile the Contract

You write your Solidity logic inside the contracts/ directory (e.g., MyContract.sol).


| CLI Command | Directory | Purpose |
|---|---|---|
| npx hardhat compile | backend/ | Compiles .sol files into Bytecode and ABI (stored in artifacts/) |


2.2 Configure Networks


Open hardhat.config.js and add a network configuration.

You will need an RPC URL (e.g., from Alchemy or Infura) and your wallet's private key (stored securely in a .env file).

backend/.env (Securely store keys):

```
PRIVATE_KEY="YOUR_WALLET_PRIVATE_KEY"
SEPOLIA_RPC_URL="YOUR_SEPOLIA_API_URL"
```

backend/hardhat.config.js (Snippet):

```
require("@nomicfoundation/hardhat-toolbox");

require('dotenv').config();

module.exports = {
  solidity: "0.8.24",
  networks: {
    sepolia: {
      url: process.env.SEPOLIA_RPC_URL,
      accounts: [process.env.PRIVATE_KEY],
    },
  },
};
```

2.3 Deployment

Modify the scripts/deploy.js to deploy your specific contract, and then execute the deployment command.

| CLI Command | Directory | Purpose |
|---|---|---|
| npx hardhat run scripts/deploy.js --network sepolia | backend/ | Deploys the contract to the Sepolia testnet. Outputs the Contract Address. |

> Key Output: The deployment script will log the Contract Address. Save this address!
>

3. ðŸŒ Frontend Integration
   
The frontend, located in my-evm-dapp/frontend/, needs the Contract ABI and Address to interact with the deployed contract.

3.1 Copy Artifacts (ABI)

The contract ABI is located in the artifacts/ folder created by Hardhat. You need to copy the JSON file containing the ABI to your frontend project.

# From the root directory: my-evm-dapp/

```
cp backend/artifacts/contracts/MyContract.sol/MyContract.json frontend/src/MyContract.json

```

3.2 Implement Web3 Interaction

In your frontend code (e.g., frontend/src/App.js), you use the Ethers.js library (installed in Step 1.2) to create a contract instance.

```
// Example Frontend JS (e.g., App.js)
import abi from './MyContract.json'; // The copied ABI file

const CONTRACT_ADDRESS = "0x...Your...Deployed...Address..."; // From Step 2.3

const provider = new ethers.providers.Web3Provider(window.ethereum);
const signer = provider.getSigner();

// Create the contract instance
const contract = new ethers.Contract(CONTRACT_ADDRESS, abi.abi, signer);

// Example of calling a contract function (transaction)
async function updateValue(newValue) {
  const tx = await contract.setValue(newValue);
  await tx.wait(); // Wait for transaction confirmation
}
```

3.3 Run and Build the Frontend

| CLI Command | Directory | Purpose |
|---|---|---|
| npm start | frontend/ | Starts the local development server to test the DApp |
| npm run build | frontend/ | Creates the production-ready static assets (HTML/CSS/JS) |

4. ðŸŒ Final Deployment (Frontend)
The final step is to take the static assets generated by npm run build (usually in a build/ folder) and deploy them to a hosting service.

| CLI Command (Example: Netlify) | Directory | Purpose |
|---|---|---|
| npm install -g netlify-cli | Global | Install the Netlify CLI |
| cd frontend | frontend/ | Navigate to the frontend directory |
| netlify deploy --prod --dir=build | frontend/ | Deploys the build/ folder content to Netlify's CDN |

Your DApp is now fully deployed:
 * Smart Contract: Deployed on the EVM-compatible chain (e.g., Sepolia).
   
 * Frontend UI: Deployed to a web server (e.g., Netlify/Vercel) and connected to the contract.

# Security is paramount in blockchain development.

While using a standard .env file with the dotenv package is common, it's considered a minimum security measure. Hardhat now offers even better, integrated solutions.


Here is an assessment of the security options, prioritizing the most robust CLI-driven methods:


## ðŸ” Secure Private Key Management for Hardhat

The primary risk of the basic .env setup is accidentally committing the file (which contains plain text private keys) to a public Git repository.

Option 1: The Basic .env Setup (Minimum Security)

This is the standard approach I used in the previous example, which relies entirely on the developer properly configuring .gitignore.

Step 1: Install dotenv

In your my-evm-dapp/backend/ directory:
```
npm install dotenv
```

Step 2: Create the .env File

Create a file named .env in the root of your Hardhat project (my-evm-dapp/backend/.env).

```
# .env file
# **CRITICAL: NEVER COMMIT THIS FILE TO GIT**
PRIVATE_KEY="0xdeadbeef...your...actual...private...key...here"
SEPOLIA_RPC_URL="https://eth-sepolia.g.alchemy.com/v2/YOUR_API_KEY"
```

Step 3: Configure .gitignore

This is the most critical step for this method. Open my-evm-dapp/backend/.gitignore and ensure the following line is present:

```
# .gitignore file
# ... other standard entries ...
.env
```

Step 4: Load Variables in hardhat.config.js
At the top of your Hardhat configuration, load the variables:

```
// hardhat.config.js
require("@nomicfoundation/hardhat-toolbox");
require('dotenv').config(); // This loads the variables

const PRIVATE_KEY = process.env.PRIVATE_KEY;

module.exports = {
  // ... other configuration ...
  networks: {
    sepolia: {
      url: process.env.SEPOLIA_RPC_URL,
      accounts: [PRIVATE_KEY], // Accessing the private key here
    },
  },
};
```

## Option 2: Hardhat Keystore (Recommended/Advanced Security)


For better security, Hardhat has introduced a built-in feature called Keystore that encrypts secrets using a master password and stores them in a project-specific, encrypted file. This allows you to safely commit the encrypted file to Git, though you must still protect your master password.

Step 1: Use the Keystore CLI Commands

Instead of writing a .env file in plain text, you use the Hardhat CLI to set encrypted secrets.

| CLI Command | Directory | Purpose |
|---|---|---|
| npx hardhat keystore set PRIVATE_KEY | backend/ | Prompts you to set a master password, then prompts you for the actual private key value. |
| npx hardhat keystore set SEPOLIA_RPC_URL | backend/ | Prompts you for the master password, then prompts for the RPC URL value. |


Step 2: Access Encrypted Secrets

Hardhat automatically handles the decryption when you run tasks that require these variables (like deployment). You will likely be prompted for the master password when deploying.


| CLI Command | Directory | Purpose |
|---|---|---|
| npx hardhat run scripts/deploy.js --network sepolia | backend/ | Executes deployment and internally decrypts the PRIVATE_KEY and SEPOLIA_RPC_URL using the master password you provide. |


Using the Hardhat Keystore significantly reduces the risk of accidentally exposing your private key compared to using a plain-text .env file.

Using the Hardhat Keystore is a more secure way to manage your sensitive credentials directly from the CLI, especially since it encrypts the values, allowing the file to be committed to version control without exposing the secrets.

Here is the step-by-step CLI guide for setting up and using the Hardhat Keystore. This assumes you are in the my-evm-dapp/backend/ directory.

## ðŸ”‘ Secure Secrets Management with Hardhat Keystore (CLI)

The Hardhat Keystore creates an encrypted file to store your secrets, protected by a master password you choose.


Step 1: Install the Keystore Plugin

While the plugin is often included in modern Hardhat installations, it's good practice to ensure it's installed.

```
# In my-evm-dapp/backend/
npm install --save-dev @nomicfoundation/hardhat-keystore
```

Step 2: Configure the Plugin

Add the plugin to your Hardhat configuration file (hardhat.config.js).
backend/hardhat.config.js (Add plugin section):

```
// hardhat.config.js
require("@nomicfoundation/hardhat-toolbox");
// require("@nomicfoundation/hardhat-keystore"); // Not strictly needed if using a Hardhat Toolbox

module.exports = {
  // ... other config ...
};
```

Step 3: Set Encrypted Secrets (CLI)

You will use the keystore set command for your private key and RPC URL. The first time you run this, you will be prompted to create your Master Password


| CLI Command | Directory | Purpose |
|---|---|---|
| npx hardhat keystore set PRIVATE_KEY | backend/ | 1. Prompts for a new Master Password. 2. Prompts for the raw Private Key value. |
| npx hardhat keystore set SEPOLIA_RPC_URL | backend/ | 1. Prompts for the Master Password (to unlock the keystore). 2. Prompts for the Sepolia RPC URL value. |


> Note: The Keystore stores these secrets in an encrypted file in your project or home directory. You must remember the Master Password, as there is no recovery mechanism!


Step 4: Configure Hardhat to Use Variables

Instead of accessing process.env, you access these variables using a built-in Hardhat function called configVariable.


backend/hardhat.config.js (Using configVariable):

```
// hardhat.config.js

// Import the function for configuration variables
const { configVariable } = require("hardhat/config");

// Retrieve the secure variables (they are decrypted internally when needed)
const PRIVATE_KEY = configVariable("PRIVATE_KEY");
const SEPOLIA_RPC_URL = configVariable("SEPOLIA_RPC_URL");

module.exports = {
  solidity: "0.8.24",
  networks: {
    sepolia: {
      url: SEPOLIA_RPC_URL,
      accounts: [PRIVATE_KEY],
    },
    // ... other networks
  },
};
```

Step 5: Deployment (The CLI Interaction)

Now, when you run your deployment, Hardhat recognizes the configVariable usage, accesses the keystore, and asks for the master password for temporary decryption.


| CLI Command | Directory | Interaction |
|---|---|---|
| npx hardhat run scripts/deploy.js --network sepolia | backend/ | The CLI will prompt: "Enter keystore password:" (You input the password you created in Step 3). |


Once the password is provided, Hardhat decrypts the variables into memory, signs the transaction with the private key, and performs the deployment. The private key never exists on disk in plain text.

Additional Keystore CLI Commands
You can manage your secrets using these commands:

| CLI Command | Purpose |
|---|---|
| npx hardhat keystore list | Lists all the keys (e.g., PRIVATE_KEY, SEPOLIA_RPC_URL) stored in the keystore. |
| npx hardhat keystore get PRIVATE_KEY | Prompts for the password and temporarily displays the raw value of the secret. |
| npx hardhat keystore change-password | Allows you to change the master password used to protect all secrets. |


Using the Hardhat Keystore ensures that your private keys are protected, even if your entire repository (including the encrypted Keystore file) is shared publicly.
