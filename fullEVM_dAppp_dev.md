# Full EVM dApp: Build and deploy

Building and deploying a full EVM (Ethereum Virtual Machine) application (DApp) from the Command Line Interface (CLI) is a multi-step process.

We will use the popular Hardhat framework for the contract side and a standard React setup for the frontend, demonstrating a typical integrated project structure.


1. âš™ï¸ (Initial Setup and Project Structure:)
[https://github.com/koyahness/open-source-projects/blob/main/Web3-dev-%20directory-%20structure.md]

1.1 Global Prerequisites


Make sure you have Node.js (with npm) and Git installed.


| CLI Command | Description |
|---|---|
| node -v | Check Node.js version |
| npm -v | Check npm version |


1.2 Create the Monorepo Structure


We will create a parent directory to hold both the backend (contracts) and the frontend.


| Path | Description |
|---|---|
| my-evm-dapp/ | Root Project Directory |
| my-evm-dapp/backend/ | Hardhat project for contracts/deployment |
| my-evm-dapp/frontend/ | React/Next.js project for the UI |


# 1. Create the root directory

```
mkdir my-evm-dapp

cd my-evm-dapp

```

# 2. Setup the backend (Hardhat)

```
mkdir backend

cd backend

npm init -y

npm install --save-dev hardhat

npx hardhat init # Select "Create a basic sample project"

cd .. # Go back to my-evm-dapp

```

# 3. Setup the frontend (React example)

```
npx create-react-app frontend

cd frontend

npm install ethers # Library to interact with the blockchain

cd .. # Go back to my-evm-dapp
```

2. ðŸ“ Backend (Smart Contract) CLI Steps
   
We focus on the my-evm-dapp/backend/ directory, which now contains the default Hardhat structure:

```
my-evm-dapp/backend/
â”œâ”€â”€ contracts/        # Your Solidity files live here
â”‚   â””â”€â”€ Lock.sol      # (Example contract from Hardhat init)
â”œâ”€â”€ scripts/          # Deployment scripts (Node.js)
â”‚   â””â”€â”€ deploy.js
â”œâ”€â”€ test/             # Test files (JavaScript/TypeScript)
â”œâ”€â”€ hardhat.config.js # Configuration file
â””â”€â”€ package.json

```

2.1 Write and Compile the Contract

You write your Solidity logic inside the contracts/ directory (e.g., MyContract.sol).


| CLI Command | Directory | Purpose |
|---|---|---|
| npx hardhat compile | backend/ | Compiles .sol files into Bytecode and ABI (stored in artifacts/) |


2.2 Configure Networks


Open hardhat.config.js and add a network configuration.

You will need an RPC URL (e.g., from Alchemy or Infura) and your wallet's private key (stored securely in a .env file).

backend/.env (Securely store keys):

```
PRIVATE_KEY="YOUR_WALLET_PRIVATE_KEY"
SEPOLIA_RPC_URL="YOUR_SEPOLIA_API_URL"
```

backend/hardhat.config.js (Snippet):

```
require("@nomicfoundation/hardhat-toolbox");

require('dotenv').config();

module.exports = {
  solidity: "0.8.24",
  networks: {
    sepolia: {
      url: process.env.SEPOLIA_RPC_URL,
      accounts: [process.env.PRIVATE_KEY],
    },
  },
};
```

2.3 Deployment

Modify the scripts/deploy.js to deploy your specific contract, and then execute the deployment command.

| CLI Command | Directory | Purpose |
|---|---|---|
| npx hardhat run scripts/deploy.js --network sepolia | backend/ | Deploys the contract to the Sepolia testnet. Outputs the Contract Address. |

> Key Output: The deployment script will log the Contract Address. Save this address!
>

3. ðŸŒ Frontend Integration
   
The frontend, located in my-evm-dapp/frontend/, needs the Contract ABI and Address to interact with the deployed contract.

3.1 Copy Artifacts (ABI)

The contract ABI is located in the artifacts/ folder created by Hardhat. You need to copy the JSON file containing the ABI to your frontend project.

# From the root directory: my-evm-dapp/

```
cp backend/artifacts/contracts/MyContract.sol/MyContract.json frontend/src/MyContract.json

```

3.2 Implement Web3 Interaction

In your frontend code (e.g., frontend/src/App.js), you use the Ethers.js library (installed in Step 1.2) to create a contract instance.

```
// Example Frontend JS (e.g., App.js)
import abi from './MyContract.json'; // The copied ABI file

const CONTRACT_ADDRESS = "0x...Your...Deployed...Address..."; // From Step 2.3

const provider = new ethers.providers.Web3Provider(window.ethereum);
const signer = provider.getSigner();

// Create the contract instance
const contract = new ethers.Contract(CONTRACT_ADDRESS, abi.abi, signer);

// Example of calling a contract function (transaction)
async function updateValue(newValue) {
  const tx = await contract.setValue(newValue);
  await tx.wait(); // Wait for transaction confirmation
}
```

3.3 Run and Build the Frontend

| CLI Command | Directory | Purpose |
|---|---|---|
| npm start | frontend/ | Starts the local development server to test the DApp |
| npm run build | frontend/ | Creates the production-ready static assets (HTML/CSS/JS) |

4. ðŸŒ Final Deployment (Frontend)
The final step is to take the static assets generated by npm run build (usually in a build/ folder) and deploy them to a hosting service.

| CLI Command (Example: Netlify) | Directory | Purpose |
|---|---|---|
| npm install -g netlify-cli | Global | Install the Netlify CLI |
| cd frontend | frontend/ | Navigate to the frontend directory |
| netlify deploy --prod --dir=build | frontend/ | Deploys the build/ folder content to Netlify's CDN |

Your DApp is now fully deployed:
 * Smart Contract: Deployed on the EVM-compatible chain (e.g., Sepolia).
   
 * Frontend UI: Deployed to a web server (e.g., Netlify/Vercel) and connected to the contract.

# Security is paramount in blockchain development.

While using a standard .env file with the dotenv package is common, it's considered a minimum security measure. Hardhat now offers even better, integrated solutions.


Here is an assessment of the security options, prioritizing the most robust CLI-driven methods:


## ðŸ” Secure Private Key Management for Hardhat

The primary risk of the basic .env setup is accidentally committing the file (which contains plain text private keys) to a public Git repository.

Option 1: The Basic .env Setup (Minimum Security)

This is the standard approach I used in the previous example, which relies entirely on the developer properly configuring .gitignore.

Step 1: Install dotenv

In your my-evm-dapp/backend/ directory:
```
npm install dotenv
```

Step 2: Create the .env File

Create a file named .env in the root of your Hardhat project (my-evm-dapp/backend/.env).

```
# .env file
# **CRITICAL: NEVER COMMIT THIS FILE TO GIT**
PRIVATE_KEY="0xdeadbeef...your...actual...private...key...here"
SEPOLIA_RPC_URL="https://eth-sepolia.g.alchemy.com/v2/YOUR_API_KEY"
```

Step 3: Configure .gitignore

This is the most critical step for this method. Open my-evm-dapp/backend/.gitignore and ensure the following line is present:

```
# .gitignore file
# ... other standard entries ...
.env
```

Step 4: Load Variables in hardhat.config.js
At the top of your Hardhat configuration, load the variables:

```
// hardhat.config.js
require("@nomicfoundation/hardhat-toolbox");
require('dotenv').config(); // This loads the variables

const PRIVATE_KEY = process.env.PRIVATE_KEY;

module.exports = {
  // ... other configuration ...
  networks: {
    sepolia: {
      url: process.env.SEPOLIA_RPC_URL,
      accounts: [PRIVATE_KEY], // Accessing the private key here
    },
  },
};
```

## Option 2: Hardhat Keystore (Recommended/Advanced Security)


For better security, Hardhat has introduced a built-in feature called Keystore that encrypts secrets using a master password and stores them in a project-specific, encrypted file. This allows you to safely commit the encrypted file to Git, though you must still protect your master password.

Step 1: Use the Keystore CLI Commands

Instead of writing a .env file in plain text, you use the Hardhat CLI to set encrypted secrets.

| CLI Command | Directory | Purpose |
|---|---|---|
| npx hardhat keystore set PRIVATE_KEY | backend/ | Prompts you to set a master password, then prompts you for the actual private key value. |
| npx hardhat keystore set SEPOLIA_RPC_URL | backend/ | Prompts you for the master password, then prompts for the RPC URL value. |


Step 2: Access Encrypted Secrets

Hardhat automatically handles the decryption when you run tasks that require these variables (like deployment). You will likely be prompted for the master password when deploying.


| CLI Command | Directory | Purpose |
|---|---|---|
| npx hardhat run scripts/deploy.js --network sepolia | backend/ | Executes deployment and internally decrypts the PRIVATE_KEY and SEPOLIA_RPC_URL using the master password you provide. |


Using the Hardhat Keystore significantly reduces the risk of accidentally exposing your private key compared to using a plain-text .env file.

Using the Hardhat Keystore is a more secure way to manage your sensitive credentials directly from the CLI, especially since it encrypts the values, allowing the file to be committed to version control without exposing the secrets.

Here is the step-by-step CLI guide for setting up and using the Hardhat Keystore. This assumes you are in the my-evm-dapp/backend/ directory.

## ðŸ”‘ Secure Secrets Management with Hardhat Keystore (CLI)

The Hardhat Keystore creates an encrypted file to store your secrets, protected by a master password you choose.


Step 1: Install the Keystore Plugin

While the plugin is often included in modern Hardhat installations, it's good practice to ensure it's installed.

```
# In my-evm-dapp/backend/
npm install --save-dev @nomicfoundation/hardhat-keystore
```

Step 2: Configure the Plugin

Add the plugin to your Hardhat configuration file (hardhat.config.js).
backend/hardhat.config.js (Add plugin section):

```
// hardhat.config.js
require("@nomicfoundation/hardhat-toolbox");
// require("@nomicfoundation/hardhat-keystore"); // Not strictly needed if using a Hardhat Toolbox

module.exports = {
  // ... other config ...
};
```

Step 3: Set Encrypted Secrets (CLI)

You will use the keystore set command for your private key and RPC URL. The first time you run this, you will be prompted to create your Master Password


| CLI Command | Directory | Purpose |
|---|---|---|
| npx hardhat keystore set PRIVATE_KEY | backend/ | 1. Prompts for a new Master Password. 2. Prompts for the raw Private Key value. |
| npx hardhat keystore set SEPOLIA_RPC_URL | backend/ | 1. Prompts for the Master Password (to unlock the keystore). 2. Prompts for the Sepolia RPC URL value. |


> Note: The Keystore stores these secrets in an encrypted file in your project or home directory. You must remember the Master Password, as there is no recovery mechanism!


Step 4: Configure Hardhat to Use Variables

Instead of accessing process.env, you access these variables using a built-in Hardhat function called configVariable.


backend/hardhat.config.js (Using configVariable):

```
// hardhat.config.js

// Import the function for configuration variables
const { configVariable } = require("hardhat/config");

// Retrieve the secure variables (they are decrypted internally when needed)
const PRIVATE_KEY = configVariable("PRIVATE_KEY");
const SEPOLIA_RPC_URL = configVariable("SEPOLIA_RPC_URL");

module.exports = {
  solidity: "0.8.24",
  networks: {
    sepolia: {
      url: SEPOLIA_RPC_URL,
      accounts: [PRIVATE_KEY],
    },
    // ... other networks
  },
};
```

Step 5: Deployment (The CLI Interaction)

Now, when you run your deployment, Hardhat recognizes the configVariable usage, accesses the keystore, and asks for the master password for temporary decryption.


| CLI Command | Directory | Interaction |
|---|---|---|
| npx hardhat run scripts/deploy.js --network sepolia | backend/ | The CLI will prompt: "Enter keystore password:" (You input the password you created in Step 3). |


Once the password is provided, Hardhat decrypts the variables into memory, signs the transaction with the private key, and performs the deployment. The private key never exists on disk in plain text.

Additional Keystore CLI Commands
You can manage your secrets using these commands:

| CLI Command | Purpose |
|---|---|
| npx hardhat keystore list | Lists all the keys (e.g., PRIVATE_KEY, SEPOLIA_RPC_URL) stored in the keystore. |
| npx hardhat keystore get PRIVATE_KEY | Prompts for the password and temporarily displays the raw value of the secret. |
| npx hardhat keystore change-password | Allows you to change the master password used to protect all secrets. |


Using the Hardhat Keystore ensures that your private keys are protected, even if your entire repository (including the encrypted Keystore file) is shared publicly.

# Refine deployment

Refining the deployment script is a crucial step, as this script is responsible for the final act of publishing your contract onto the Ethereum Virtual Machine (EVM).


Here is a step-by-step guide to structure and execute the deployment script (scripts/deploy.js) using Hardhat.

This script will ensure the contract is properly deployed and its address is logged for the frontend.

## ðŸ“ Refining the Deployment Script (scripts/deploy.js)

The default Hardhat script is usually good, but we will modify it to handle standard best practices like logging the contract address and handling errors gracefully.

Step 1: Examine the Directory Structure

Ensure you are familiar with the path to the script and the contract:

```
my-evm-dapp/backend/
â”œâ”€â”€ contracts/
â”‚   â””â”€â”€ MyContract.sol # Your main contract
â””â”€â”€ scripts/
    â””â”€â”€ deploy.js      # The script we are modifying
```

Step 2: Modify deploy.js

We use the Hardhat Runtime Environment (HRE), which gives us access to ethers and hre.ethers.getContractFactory.
backend/scripts/deploy.js:

```
// A standard async function to handle the deployment
async function main() {
  // 1. Get the Contract Factory
  // 'MyContract' should exactly match the name of the contract in MyContract.sol
  const MyContract = await hre.ethers.getContractFactory("MyContract");

  // 2. Deployment (Instantiation)
  // If your contract constructor takes arguments, pass them here.
  // Example: const myContract = await MyContract.deploy(initialValue, anotherParam);
  const myContract = await MyContract.deploy();

  // 3. Wait for the transaction to be mined
  // This ensures the script doesn't finish until the contract is live on the chain
  await myContract.waitForDeployment();

  // 4. Logging the Address
  // Crucial step: This is the address the frontend must use.
  const contractAddress = await myContract.getAddress();
  console.log(`\nContract 'MyContract' deployed to: ${contractAddress}`);

  // Optional: Write the address and ABI to a file for the frontend
  // (This is an advanced step, often done using the Hardhat deploy plugin)
  // For now, we manually copy the ABI and address.
}

// 5. Error Handling and Execution
main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error(error);
    process.exit(1);
  });

```

Step 3: Execute the Deployment (CLI)

Navigate to your backend directory and run the command, providing your Master Password when prompted.


| CLI Command | Directory | Purpose |
|---|---|---|
| npx hardhat run scripts/deploy.js --network sepolia | backend/ | Executes the script using the configuration for the Sepolia testnet. |


Expected CLI Output:

Enter keystore password: ********

Contract 'MyContract' deployed to: 0x5FbDB2315678afec80c5D7494A346907d39d91a9

Step 4: Finalizing Frontend Connection

After deployment, you have two key pieces of information needed for your my-evm-dapp/frontend/ project:

 * Contract Address: The address logged in the CLI output (e.g., 0x5FbDB...).
 * Contract ABI: The JSON file located at backend/artifacts/contracts/MyContract.sol/MyContract.json.
As noted in the earlier steps, you must now copy that ABI file to your frontend project and hardcode (or use an environment variable for) the deployed Contract Address in your frontend source code to enable interaction.

## Connecting artefacts to front end

Connecting the compiled contract artifacts (especially the ABI) to the frontend is the final CLI and configuration step before writing the UI logic.

Here is the step-by-step CLI process for transferring the necessary data, followed by how it is consumed in your React frontend.


# ðŸ”— Connecting Backend Artifacts to the Frontend

Step 1: Examine the Artifacts Directory

When you run npx hardhat compile, Hardhat creates an artifacts/ folder containing the crucial JSON file that holds the contract's ABI and Bytecode.

```
my-evm-dapp/backend/
â””â”€â”€ artifacts/
    â””â”€â”€ contracts/
        â””â”€â”€ MyContract.sol/
            â””â”€â”€ MyContract.json  <-- This is the file we need
```

Step 2: Copy the Artifacts (CLI Command)

From the root of your entire project (my-evm-dapp/), execute the copy command to move the MyContract.json file into your frontend source directory (frontend/src/).

| CLI Command | Directory | Purpose |
|---|---|---|
| cp backend/artifacts/contracts/MyContract.sol/MyContract.json frontend/src/MyContract.json | my-evm-dapp/ | Copies the compiled contract JSON (containing the ABI) to the React source folder. |


Step 3: Define the Contract Address

In a real application, you would manage the contract address using environment variables, but for simplicity, we will define it in the frontend code.

Save the Address: Remember the address you logged during deployment (e.g., 0x5FbDB...).

## âš›ï¸ Frontend Integration (frontend/src/)

Now that the ABI file (MyContract.json) is in the frontend, you can use the Ethers.js library to create an instance of your contract and start interacting with the blockchain.

Step 4: Import and Initialize Ethers.js
In your main application file (e.g., frontend/src/App.js):

```
// frontend/src/App.js

import { ethers } from 'ethers';
// 1. Import the copied JSON artifact
import contractArtifact from './MyContract.json';

// 2. Define the deployed address (replace this with your actual address)
const CONTRACT_ADDRESS = "0x5FbDB2315678afec80c5D7494A346907d39d91a9";

// 3. Extract the ABI
const contractABI = contractArtifact.abi;


async function connectWalletAndGetContract() {
  // Check for the presence of a wallet provider (e.g., MetaMask)
  if (window.ethereum) {
    try {
      // Request account access
      await window.ethereum.request({ method: 'eth_requestAccounts' });

      // Create a Web3 Provider (read access)
      const provider = new ethers.BrowserProvider(window.ethereum);

      // Get the Signer (write access, required for sending transactions)
      const signer = await provider.getSigner();

      // 4. Create the Contract Instance
      const contract = new ethers.Contract(CONTRACT_ADDRESS, contractABI, signer);

      console.log("Wallet connected and Contract ready!");
      return contract;

    } catch (error) {
      console.error("User rejected access or connection failed:", error);
      return null;
    }
  } else {
    console.log("No Ethereum provider detected. Please install MetaMask.");
    return null;
  }
}

// ... Rest of your React component logic ...
```

Step 5: Interact with the Contract Functions

Once you have the contract object (from Step 4), you can call its functions defined in your Solidity code.

A. Reading State (Free/View Functions)

```
async function readCurrentValue(myContract) {
  try {
    // Calling a view function (no gas cost)
    const value = await myContract.getValue();
    console.log("Current contract value:", value.toString());
    return value.toString();
  } catch (error) {
    console.error("Error reading value:", error);
  }
}

'''

B. Writing State (Transaction Functions)

'''
async function updateContractValue(myContract, newValue) {
  try {
    // Calling a state-changing function (requires gas and wallet signature)
    const tx = await myContract.setValue(newValue);

    // Wait for the transaction to be mined and confirmed
    console.log(`Sending transaction... Hash: ${tx.hash}`);
    await tx.wait();
    console.log("Transaction confirmed successfully!");

  } catch (error) {
    console.error("Transaction failed:", error);
  }
}
```

You now have a complete, secure, CLI-driven workflow:
 * Backend CLI: Hardhat setup and Keystore usage.
 * Deployment CLI: Running npx hardhat run to get the Contract Address.
 * Integration CLI: Using cp to transfer the ABI.
 * Frontend Logic: Using Ethers.js to connect and interact.


# Final step, running the development 

That's the final mile! To test your full DApp connection, you will need two terminal sessions running concurrently:

one for your local Hardhat node (to simulate the blockchain) and one for your React development server.

## ðŸƒ Running and Testing the Full DApp

Step 1: Start the Local Hardhat Node (Terminal 1)

If you deployed to a testnet like Sepolia, you can skip this step, but for rapid local development and testing, running a local node is essential.

Goal: Start a private, local EVM node that your wallet (MetaMask) can connect to, complete with pre-funded accounts.

| CLI Command | Directory | Purpose |
|---|---|---|
| npx hardhat node | backend/ | Starts the Hardhat local network on http://127.0.0.1:8545. Keep this terminal running. |

> Note: The local node will log 20 sample accounts and their private keys. Copy one of these private keys to import into MetaMask for testing.


Step 2: Configure MetaMask for Localhost

Before running the frontend, ensure your browser wallet is pointed at the local node.

 * Open MetaMask and click the network selector.
 * Add a new network (or select "Localhost 8545" if it appears automatically).
   * Network Name: Localhost 8545 (or Hardhat Local)
   * New RPC URL: http://127.0.0.1:8545
   * Chain ID: 31337
 * Import Account: Use the private key of one of the 20 accounts logged in Terminal 1 to import a test account. This account will have funds to pay for gas on your local chain.


Step 3: Start the Frontend Development Server (Terminal 2)


Open a second terminal window, navigate to your frontend directory, and start the React server.

| CLI Command | Directory | Purpose |
|---|---|---|
| npm start | frontend/ | Starts the React development server, usually opening the DApp in your browser at http://localhost:3000. |


Step 4: Test the Connection and Interaction

With both the backend node and the frontend server running:

 * In your browser, ensure MetaMask is connected to the Localhost 8545 network.
 * Your frontend code (e.g., the connectWalletAndGetContract function from Step 4 in the previous response) will now attempt to connect to the wallet via window.ethereum.
 * Test your contract interactions:
   * View functions: Call a read function (e.g., readCurrentValue) to ensure data is fetched from the local Hardhat node.
   * Transaction functions: Call a write function (e.g., updateContractValue). MetaMask should pop up, prompting you to confirm and sign the transaction, using gas from your imported test account.

   
This completes the full CLI-driven development and deployment cycle for your EVM DApp!

If you're having trouble running npm start on your React app,

npm start error in React (SOLVED) will give you solutions if you encounter common issues when trying to launch your React development server.

